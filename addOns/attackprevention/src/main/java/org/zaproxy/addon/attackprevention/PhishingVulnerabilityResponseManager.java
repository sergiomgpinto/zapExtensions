package org.zaproxy.addon.attackprevention;

import org.apache.commons.httpclient.URIException;
import org.parosproxy.paros.network.HttpMalformedHeaderException;
import org.parosproxy.paros.network.HttpMessage;
import org.zaproxy.addon.attackprevention.database.Credentials;
import org.zaproxy.addon.attackprevention.database.PasswordHygieneHistory;
import org.zaproxy.addon.attackprevention.database.PhishingHistory;
import org.zaproxy.addon.attackprevention.parser.FormParser;
import org.zaproxy.addon.attackprevention.parser.JSONParser;
import org.zaproxy.addon.attackprevention.parser.Parser;
import org.zaproxy.addon.attackprevention.ui.PhishingWarningCreator;
import org.zaproxy.addon.attackprevention.utils.JSONLoader;
import org.zaproxy.addon.attackprevention.vulnerability.PasswordHygieneVulnerability;
import org.zaproxy.addon.attackprevention.vulnerability.PhishingVulnerability;

import java.util.List;
import java.util.Objects;

/**
 * This class implements the logic to handle a request with
 * form submissions in order to detect a possible
 * phishing attack.
 *
 * @see AttackPreventionResponseManager
 */
public class PhishingVulnerabilityResponseManager extends AttackPreventionResponseManager {

    private static final String PASSWORD_WARNING = "PasswordWarning";
    private static final String LOGIN_WARNING = "LoginWarning";
    private final PasswordHygieneHistory pwdHistory;
    private final PhishingHistory phishingHistory;
    private final List<Parser> parsers;
    private HttpMessage msg;
    private final String PASSED_RULE = JSONLoader.getLabel("PASSED_RULE");

    public PhishingVulnerabilityResponseManager() {
        pwdHistory = new PasswordHygieneHistory();
        phishingHistory = new PhishingHistory();
        parsers = List.of(new FormParser(), new JSONParser());
    }

    /**
     * Enters in saveUserChoices condition if this request has url parameters
     * from the user choices in the warning pages.
     * Enters in isPhishingAttack condition if it detects a possible phishing
     * attack.
     * The method isUrlLegitimate checks if the following website is legitimate
     * for the user, which means that he already clicked continue to log in on
     * a previous login warning page for this website. If so, there's no need
     * to show the warning page.
     * The method storeRequest stores the request so that for the next
     * request when the user has chosen what to do in the warning
     * page we do not lose the information for the login.
     * The method createResponse attaches the login warning page to the
     * response body of the request.
     * If we enter on the else of the isPhishingAttack condition it means
     * is the first time the user log in to a website.
     * Enters in the !Object.equals condition if the password hygiene
     * mechanism has failed which means the password is weak.
     * Enters in the getUserPasswordWarningPreference condition if
     * the user has previously chosen not to see anymore the warning
     * page for the specific website.
     * Reaches to the storeCredentialsAndWebsite method if its the first time
     * the user is loggin in any website and the password hygiene mechanism
     * is disabled which means we can safely store the credentials.
     * @param msg - Request in the format of a HttpMessage.
     *
     */
    @Override
    public void respond(HttpMessage msg) {

        this.msg = msg;
        Request request = parseToValidRequest(msg);
        if (request == null) {
            System.out.println("The parsers available could not parse the message.");
            return;
        }
        String cleanedUrl = request.getCleanedUrl();

        if (saveUserChoices(request)) {
            return;
        }

        if (isRequestForFormSubmission(request)) {
            if (isPhishingAttack(request)) {
                if (isUrlLegitimate(request)){
                    return;
                }
                String[] args = {cleanedUrl, cleanedUrl};
                String warningPage = showWarningPage(args, LOGIN_WARNING);
                storeRequest(request);
                createResponse(warningPage);
            }
            else {
                if (isPasswordHygieneMechanismEnabled()) {
                    String result = passwordHygieneMechanism(request);
                    if (!Objects.equals(result, PASSED_RULE)) {
                        if (pwdHistory.getWarningPreference(request.getUsername(),
                                cleanedUrl)) {
                            return;
                        }
                        String[] args = {cleanedUrl,result};
                        String warningPage = showWarningPage(args, PASSWORD_WARNING);
                        storeRequest(request);
                        createResponse(warningPage);
                        return;
                    }
                }
                storeCredentialsAndWebsite(request);
            }
        }
    }

    /**
     * Triggers specific actions based on the url parameters
     * introduced by clicking on the warning page buttons.
     * Enters in the isToCancelLogin condition if the user has
     * chosen to cancel the login after the login warning page.
     * Enters the isToContinueLogin condition if the user has
     * chosen to continue the login after the login warning
     * page. Since he decided to login we need to store his
     * information in the database and remember his preference
     * for the specific website which now becomes trusted.
     * Enters the isToNotShowAgainPasswordWarning condition if
     * the user has chosen that for the specific website he
     * no longer wants to see the password warning page.
     * Enters the isToContinueToShowPasswordWarning condition
     * if the user did not choose to stop seeing the password
     * warning page for the specific website.
     *
     * @param request - The request with the query parameters
     * for the specific action chosen in the warning page.
     * @return - true if the request has one of the four
     * query parameters below else false.
     */
    @Override
    public boolean saveUserChoices(Request request) {
        String cleanedUrl = request.getCleanedUrl();
        try {
            setHeader(msg,cleanedUrl);
        } catch (URIException e) {
            e.printStackTrace();
        }

        if (request.isToCancelLogin()) {
            return true;
        }

        String[] previousReqInfo = getLastRequest();
        request.setUsername(previousReqInfo[0]);
        request.setPassword(previousReqInfo[1]);
        storeCredentialsAndWebsite(request);

        if (request.isToContinueLogin()) {
            saveUserLoginPreference(request);
            return true;
        }
        else if (request.isToNotShowAgainPasswordWarning()) {
            saveUserPasswordWarningPreference(request.getUsername(), cleanedUrl);
            return true;
        }
        else return request.isToContinueToShowPasswordWarning();
    }

    /* Auxiliary methods*/

    /**
     * Parses the msg through all the parsers instances in order to get a
     * valid request entity for this manager.
     * @param msg - The message to be parsed.
     * @return the request.
     */
    private Request parseToValidRequest(HttpMessage msg) {
        for (Parser p : parsers) {
            Request request = p.parseMessage(msg);
            if (request.getPassword() != null && request.getUsername() != null) {
                return request;
            }
        }
        return null;
    }

    /**
     * Fetches from the database the last request which contains
     * the login credentials that made the warning page be shown
     * to the user.
     *
     * @return username + : + password
     */
    private String[] getLastRequest () {
        return phishingHistory.getLastRequest().split(":");
    }

    /**
     * It is true that this method is also in the other ResponseManger type
     * but they have different arguments and returns therefore we decided not to
     * unify although their purpose being the same.
     *
     * @param typeOfWarningPage - Choses the type of warning page to be shown
     * to the user according to the situation.
     */
    private String showWarningPage(String[] args, String typeOfWarningPage) {

        PhishingWarningCreator warningCreator = new PhishingWarningCreator();
        String warningPageHtml;

        if (typeOfWarningPage.equals(PASSWORD_WARNING)) {

            String continueUrl = args[0];
            String reason = args[1];

            warningPageHtml = warningCreator.createWarningPage(PASSWORD_WARNING, continueUrl, reason);
        }
        else {
            String goBackURL = args[0];
            String continueURL = args[1];

            warningPageHtml = warningCreator.createWarningPage(LOGIN_WARNING,goBackURL,continueURL);
        }
        return warningPageHtml;
    }

    /**
     * This method allows to save in the database that a user no
     * longer wants to see the password warning page for a specific
     * website.
     *
     * @param username - The username of the user.
     * @param website - The website the user is trying to login to.
     */
    private void saveUserPasswordWarningPreference(String username, String website) {
        pwdHistory.saveWarningPreference(username, website);
    }

    /**
     * @param request - The request to be checked.
     * @return true if this request has the form
     * keywords detailed in the assignment.
     */
    private boolean isRequestForFormSubmission(Request request) {

        String body = request.getBody();

        if (body.contains("username") || body.contains("user")
                || body.contains("uname") || body.contains("email")
                || body.contains("identifier") || body.contains("login")) {
            return body.contains("password") || body.contains("pass")
                    || body.contains("pwd") || body.contains("passwd");
        }
        return false;
    }

    /**
     * This method allows for, for example, when a user tries to login
     * and gets the warning page, the user can choose to continue
     * with the login pressing the continue button. Since that
     * request no longer has the login credentials in the body,
     * we fetch it from the database for the respective user
     * with this method.
     *
     * @param request - The request to be stored.
     */
    private void storeRequest(Request request) {
        phishingHistory.storeRequest(request.getUsername(),request.getPassword());
    }

    /**
     * @param request - The request to be checked.
     * @return true if this request is a post message and its a login
     * for a website with some credentials that were used for a
     * previous website login.
     */
    private boolean isPhishingAttack(Request request) {

        if (request.isPostRequest()) {

            String username = request.getUsername();
            String password = request.getPassword();
            String website = request.getCleanedUrl();

            if (username == null || password == null) {
                return false;
            }

            return evaluateVulnerability(username, password, website);
        }
        return false;
    }

    /**
     * @param username - The user username.
     * @param password - The user password.
     * @param website - The website the credentials were sent to login.
     * @return true if there was an attack false otherwise.
     */
    private boolean evaluateVulnerability(String username, String password, String website) {
        PhishingVulnerability attack = new PhishingVulnerability(username, password, website);

        return !Objects.equals(attack.evaluateVulnerability(), PASSED_RULE);
    }

    /**
     * This method allows to store the credentials of the user login
     * to the respective website.
     *
     * @param request - The request object.
     */
    private void storeCredentialsAndWebsite(Request request) {
        if (request.getUsername() == null || request.getPassword() == null) {
            return;
        }
        phishingHistory.addVisitedSite(request.getUsername()
                , request.getPassword()
                , request.getCleanedUrl());
    }

    /**
     * Checks if the password mechanism is available.
     *
     * @return true if the password mechanism is enabled
     * else false.
     */
    private boolean isPasswordHygieneMechanismEnabled() {
        return pwdHistory.isMechanismEnabled();
    }

    /**
     * This method is responsible for evaluating the
     * strength of the user password.
     *
     * @param request - The request to be checked.
     * @return PASSED_RULE if the user password
     * passes all the passwordHygiene rules
     * else the according message.
     */
    private String passwordHygieneMechanism(Request request) {
        PasswordHygieneVulnerability vulnerability = new
                PasswordHygieneVulnerability(request.getPassword());
        return vulnerability.evaluateVulnerability();
    }

    /**
     * This method is responsible for creating the body response
     * to the user request where the warning page is inserted.
     *
     * @param html - The html of the warning page. to be attached
     * to the response.
     */
    private void createResponse(String html) {
        try {
            setMsgBody(msg, html);
        } catch (HttpMalformedHeaderException e) {
            e.printStackTrace();
        }
    }

    /**
     * If a user continues after the login warning page, the website
     * becomes a legitimate website for the user and the user's
     * preference is stored for the future.
     *
     * @param request - The request to be checked.
     */
    private void saveUserLoginPreference(Request request) {
        Credentials credentials = phishingHistory.getCredential(request.getUsername()
                , request.getPassword());
        phishingHistory.addLegitimateSite(credentials,request.getCleanedUrl());
    }

    /**
     * This method allows to detect if the website in this
     * request is a legitimate website.
     *
     * @param request - The request to be checked.
     * @return  true if it is else false
     */
    private boolean isUrlLegitimate(Request request) {
        Credentials credentials = phishingHistory.getCredential(request.getUsername()
                , request.getPassword());
        phishingHistory.isLegitimateSite(credentials, request.getCleanedUrl());
        return phishingHistory.isLegitimateSite(credentials, request.getCleanedUrl());
    }
}

